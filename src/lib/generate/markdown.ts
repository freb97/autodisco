import type { OutputResult, SchemaResult } from '../../types'
import type { ParsedDiscoverConfig } from '../config'
import { writeFile } from 'node:fs/promises'

import { joinURL } from 'ufo'
import { resolveTypeName } from '../../helpers/path'
import { buildAST } from './ast/builder'
import { writeAST } from './ast/writer'

type ListItem = string | { text: string, link?: string, children?: ListItem[] }

function paragraph(text: string) {
  return `${text}`
}

function header(title: string, level: number = 1) {
  return `${'#'.repeat(level)} ${title}`
}

function list(items: ListItem[], level: number = 0) {
  return items.map((item) => {
    let content = ''

    if (typeof item === 'string') {
      content += `${'  '.repeat(level)}- ${item}`
    }
    else {
      content += `${'  '.repeat(level)}- ${item.link ? `[${item.text}](${item.link})` : item.text}`

      if (item.children) {
        content += `\n${list(item.children, level + 1)}`
      }
    }

    return content
  }).join('\n')
}

function code(content: string, language: string = '') {
  return `\`\`\`${language}\n${content}\n\`\`\``
}

function mapOutputs(items: OutputResult[], callback: (method: string, output: OutputResult[]) => any) {
  return Object.entries(items.reduce((acc, result) => {
    acc[result.method] = acc[result.method] || []
    acc[result.method]?.push(result)

    return acc
  }, {} as Record<string, OutputResult[]>)).map(([method, results]) => callback(method, results))
}

function generateMarkdown(nodes: (string | string[])[], separator: string = '\n\n') {
  return nodes.flat().join(separator).concat('\n')
}

function generateEntrySection(config: ParsedDiscoverConfig, schemaResults: SchemaResult[]) {
  return [
    header('API Documentation'),
    paragraph(`This documentation was generated by [AutoDisco](https://github.com/freb97/autodisco).`),
    list([
      `API Url: ${config.baseUrl ?? schemaResults.at(0)?.path ?? ''}`,
      `Generated on: ${new Date().toISOString()}`,
    ]),
  ]
}

function generateConfigurationSection(config: ParsedDiscoverConfig) {
  const nodes = []

  if (config.headers) {
    nodes.push(header('Configuration', 2))
    nodes.push(header('Headers', 3))
    nodes.push(list(Object.keys(config.headers).map(name => `\`${name}\`: \`string\``)))
  }

  return nodes
}

function generateEndpointsSection(
  schemaResults: SchemaResult[],
  typescript: OutputResult[] | undefined,
  zod: OutputResult[] | undefined,
  json: OutputResult[] | undefined,
) {
  const nodes = [header('Discovered Endpoints', 2)]

  if (schemaResults.length === 0) {
    nodes.push(paragraph('No endpoints were discovered.'))
    return nodes
  }

  const groupedByMethod = schemaResults.reduce((acc, result) => {
    acc[result.method] = acc[result.method] || []
    acc[result.method]?.push(result)

    return acc
  }, {} as Record<string, SchemaResult[]>)

  Object.entries(groupedByMethod).forEach(([method, results]) => {
    nodes.push(...[
      header(`${method.toUpperCase()}`, 3),
      paragraph(`Found ${results.length} ${results.length > 1 ? 'endpoints' : 'endpoint'}:`),
      list(results.map(result => `\`${result.path}\``)),
    ])

    Object.values(results).forEach((result) => {
      nodes.push(...[
        header(`${method.toUpperCase()} ${result.path}`, 4),
      ])

      if (result.config.headers) {
        nodes.push(...[
          header('Request Headers', 5),
          list(Object.keys(result.config.headers).map(name => `\`${name}\`: \`string\``)),
        ])
      }

      if (result.config.params) {
        nodes.push(...[
          header('Path Parameters', 5),
          list(Object.keys(result.config.params).map(name => `\`${name}\`: \`${typeof result.config.params?.[name]}\``)),
        ])
      }

      if (result.config.query) {
        nodes.push(...[
          header('Query Parameters', 5),
          list(Object.keys(result.config.query).map(name => `\`${name}\`: \`${typeof result.config.query?.[name]}\``)),
        ])
      }

      if (result.bodySchema) {
        nodes.push(...[
          header('Request Body', 5),
          code(writeAST(buildAST(result.bodySchema), { lang: 'typescript' }), 'ts'),
        ])
      }

      nodes.push(header('Response Schemas', 5))

      if (typescript) {
        const tsResult = typescript.find(r => r.path === result.path && r.method === result.method)

        if (tsResult) {
          nodes.push(...[
            paragraph('TypeScript Types:'),
            code(tsResult.output, 'ts'),
          ])
        }
      }

      if (zod) {
        const zodResult = zod.find(r => r.path === result.path && r.method === result.method)

        if (zodResult) {
          nodes.push(...[
            paragraph('Zod Schema:'),
            code(zodResult.output, 'ts'),
          ])
        }
      }

      if (json) {
        const jsonResult = json.find(r => r.path === result.path && r.method === result.method)

        if (jsonResult) {
          nodes.push(...[
            paragraph('JSON Schema:'),
            code(jsonResult.output, 'json'),
          ])
        }
      }
    })
  })

  return nodes
}

function generateFilesSection(
  config: ParsedDiscoverConfig,
  openapi: string | undefined,
  typescript: OutputResult[] | undefined,
  zod: OutputResult[] | undefined,
  json: OutputResult[] | undefined,
) {
  const nodes = []

  if (openapi || zod || json || (typescript && config.generate?.typescript)) {
    nodes.push(header('Generated Files', 2))
  }

  if (openapi) {
    nodes.push(...[
      header('OpenAPI', 3),
      list([
        `[OpenAPI Schema](./openapi/schema.json)`,
        `[OpenAPI TypeScript Types](./openapi/types.d.ts)`,
      ]),
    ])
  }

  if (typescript && config.generate?.typescript) {
    nodes.push(...[
      header('TypeScript Types', 3),
      list(mapOutputs(typescript, (method, output) => ({
        text: `${method.toUpperCase()}`,
        children: output.map(result => ({
          text: `${result.name}.ts`,
          link: `./typescript/${method}/${result.name}.ts`,
        })),
      }))),
    ])
  }

  if (zod && config.generate?.zod) {
    nodes.push(...[
      header('Zod Schemas', 3),
      list(mapOutputs(zod, (method, output) => ({
        text: `${method.toUpperCase()}`,
        children: output.map(result => ({
          text: `${result.name}.ts`,
          link: `./zod/${method}/${result.name}.ts`,
        })),
      }))),
    ])
  }

  if (json && config.generate?.json) {
    nodes.push(...[
      header('JSON Schemas', 3),
      list(mapOutputs(json, (method, output) => ({
        text: `${method.toUpperCase()}`,
        children: output.map(result => ({
          text: `${result.name}.ts`,
          link: `./json/${method}/${result.name}.json`,
        })),
      }))),
    ])
  }

  return nodes
}

/**
 * Generate Markdown file from parsed schema results
 */
export async function generateMarkdownSchema(
  schemaResults: SchemaResult[],
  openapi: string | undefined,
  typescript: OutputResult[] | undefined,
  zod: OutputResult[] | undefined,
  json: OutputResult[] | undefined,
  config: ParsedDiscoverConfig,
) {
  if (!config.generate?.markdown) {
    return
  }

  if (!typescript) {
    typescript = schemaResults.map(result => ({
      name: resolveTypeName(joinURL(config.baseUrl ?? '', result.path)),
      path: result.path,
      method: result.method,
      output: writeAST(buildAST(result.schema), { lang: 'typescript' }),
    }))
  }

  const markdownDocument = generateMarkdown([
    generateEntrySection(config, schemaResults),
    generateConfigurationSection(config),
    generateEndpointsSection(schemaResults, typescript, zod, json),
    generateFilesSection(config, openapi, typescript, zod, json),
  ])

  await writeFile(joinURL(config.outputDir, 'API.md'), markdownDocument)

  await config.hooks.callHook('markdown:generated', config, markdownDocument)

  return markdownDocument
}
